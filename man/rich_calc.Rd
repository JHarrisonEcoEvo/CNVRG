% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convrg_func.R
\name{rich_calc}
\alias{rich_calc}
\title{Calculate richness estimates for each replicate}
\usage{
rich_calc(model_out, countData, params = "pi", threshold = 0.01)
}
\arguments{
\item{model_out}{Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI or isd_transform}

\item{countData}{Dataframe of count data that was modelled. Should be exactly the same as those data modelled! The first field should be sample name and integer count data should be in all other fields.}

\item{params}{Parameter for which to calculate richness, can be 'p' or 'pi' or both (e.g., c("pi","p"))}

\item{threshold}{Threshold to use for calculating richness.}
}
\value{
Posterior probability distribution of richness estimates for each parameter.
}
\description{
Calculate richness for each replicate while propagating uncertainty in relative abundance estimates through calculations.
}
\details{
Takes as input either a fitted Stan oject from the cnvrg_HMC or cnvrg_VI functions, or the output of isd_transform.
As always, doublecheck the results to ensure the function has output reasonable values. This function takes the output of
the Dirichlet or multinomial parameters and counts however many parameters exceed some threshold (for each sample from the posterior).
The choice of threshold is arbitrary and made by the user. Try a few values for the threshold and see how the patterns
in richness shift. This is akin to rarefying one's count data to different levels of observation effort.

NOTE: richness is a very fraught metric with sequencing data because the data are compositional. An extremely abundant
taxon could dominate the sequencer output causing richness to appear to have dropped when, in fact, it had not. Therefore,
richness estimates should be approached cautiously and the absolute value of the richness estimate should be regarded as nearly
meaningless. Instead, richness should only be used in a relative sense, to compare among samples that have relatively similar
rank-abundance profiles and that were processed in the same way and that had similar sequencing depth.
}
\examples{
#simulate an OTU table
com_demo <-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] <- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] <- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames <- NA
for(i in 1:length(com_demo[1,])){
fornames[i] <- paste("otu_", i, sep = "")
}
sample_vec <- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] <- paste("sample", i, sep = "_")
}
com_demo <- data.frame(sample_vec, com_demo)
names(com_demo) <- c("sample", fornames)

out <- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
rich <- rich_calc(model_out = out,params = c("pi","p"),
countData = com_demo, threshold = 0.1)
}
